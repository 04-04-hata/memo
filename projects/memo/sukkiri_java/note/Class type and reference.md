〜クラス型と参照〜

インスタンスの事は「操作と属性を持ち、コンピューター内の仮想世界に生み出される登場人物」という概念的な表現をしてきたが
実際は勇者やばけばけばーのような存在がコンピューターの中に住んでおり、あれこれ活躍する訳ではない。<br>
Javaの仮想世界と表現してきたものは実際にはコンピューターのメモリ領域で、この領域は、javaのプログラムを実行する際に
JVMが大量にメモリ領域(通常は数百MB〜数GB)を使って準備するもので、ヒープという。<br>
そして、私たちがnewを用いてインスタンスを生み出すたびにヒープの一部の領域(通常は数十〜数百バイト)が確保され、
インスタンスの情報を格納するために利用される。<br>
そのため、多くの属性を持った大きなクラスをインスタンス化すると、消費されるヒープ領域は必要とする容量に従って大きくなる。<br>

インスタンスとは、「ヒープの中に確保されたメモリ領域」に過ぎない<br>

クラス型変数とその内容
インスタンスが生まれる際に、コンピューターの中で何が起こっているか、以下のコード↓を例に探っていく<br>

public class Buttle {<br>
  public static void main (String args) {<br>
  // 勇者を生成<br>
    Hero h = new Hero(); // Heroクラスからインスタンスを生成し、変数hに入れる<br>
    h = new Hero();<br>
    h.hp = 100;<br>
  }<br>
}<br>

1.Hero型変数の確保<br>
最初に動くのはHero h;<br>
この行↑を実行するとJVMはHero型の変数hをメモリ内に準備する。<br>
JVMは広いヒープ領域の中から現在利用していないメモリ領域を探し出して自動的にそこを確保してくれる。<br>
1928番地が空いていたとして、ここが変数h用に確保されたとする。<br>

この段階↑ではまだ勇者自体は生まれていない。<br>
Hero型の箱が準備されるだけで、この箱には数値や文字列を入れる事は出来ないし、Hero型でないばけばけばーインスタンスを入れる事も出来ない。<br>

2.Heroインスタンスの生成<br>
Hero h = new Hero();は代入文。代入の場合は左辺より先に右辺が評価される。<br>
(つまりnew Hero();が先に評価される)<br>
new Hero();が実行されるとJVMはヒープ領域から必要な量のメモリを確保する。<br>
今回は仮に3922番地から24バイト分(3922〜3945番地)が確保出来たとする。<br>

1928番地が変数hの場所と考える。<br>
3922番地は生まれたHeroインスタンスの情報領域。<br>
3922〜3945番地(24バイト分)には名前フィールドの保存領域やHPフィールドの保存領域が入っている。<br>
new Hero();をすることにより、仮想世界に勇者という存在が生まれる。<br>
しかし、まだHeroインスタンスには属性が設定されていない為、名前は空っぽ、HPは0となる。<br>

3.参照の代入
参照…変数に入っているアドレス情報。<br>

右辺(new Hero();)が実行された後の事について<br>
右辺の実行が終了した後、h = new Hero();とは「h = 右辺の実行結果」という状態になる。<br>
つまり、右辺の実行結果を変数hに代入するという事が行われる。<br>
変数hに代入される右辺の実行結果は、newによって生成されるインスタンスのために確保されたメモリの先頭番地(3922番地)。
今回の場合はnew Hero();により勇者インスタンスが3922〜3945番地に生成されているので、変数hには3922という数値が代入される。<br>
変数hに入っている3922はただの数値に過ぎず、Heroインスタンスに関する名前やHPなどの様々な情報は変数hの中ではなく、別のところにある。<br>
見方を変えれば、この変数hにはHeroインスタンスの情報の全部は入りきらないから、詳しくは3922番地を参照(見る)してとも捉える事が出来る。<br>
このようなことから、変数hに入っているアドレス情報を参照という。<br>

int[]型やString[]型と言った配列型も、変数に入っているのは「実際の配列内の各データが保存されているメモリ領域の先頭番地」。<br>
Hero型のようなクラス型も原理は同じ。このことからクラス型と配列型は総称して参照型と呼ばれる。<br>

4.フィールドへの値の代入<br>
h.hp = 100;では、変数hに格納されている勇者のHPを100に設定する。この行をJVMは以下のように↓解釈して実行する。<br>

1.変数hの内容を調べると、「3922番地を参照しろ」と書かれている。<br>
2.メモリ内の3922番地にあるインスタンスのメモリ領域にアクセスし、その中のhpフィールド部分を100に書き換える。<br>

2でやってることの具体例:3922〜3945番地のHPフィールドの保存領域を100に書き換える。<br>

↑上記のように、まず変数から番地情報を取り出し、次にその番地にアクセスするというJVMの動作を参照の解決やアドレス解決という<br>