〜コンストラクタ〜

「インスタンスが生まれた直後に自動実行される処理」を予め定義する<br>

生まれた直後の動作を定義したHeroクラス<br>

public class Hero {<br>
	String name;
	int hp;
	Sword sword; // 勇者が装備している剣の情報
	
	public void attack() {
		System.out.println(this.name + "は" + this.sword.name + "で攻撃した");
	}
	
	public Hero() {
    this.hp = 100; // hpフィールドを100で初期化
  }
	
	
}<br>

追加したメソッド:public Hero()<br>
効果:hpフィールドを100で初期化<br>
public Heroの役割:newされた直後に自動的に実行するメソッド<br>

このクラス↑にはHero()というメソッドが追加されている。<br>
attack()などの通常のメソッドは誰かから呼ばれないと動かないものですが、<br>
このHero()だけは「このクラスがnewされた直後に自動的に実行される」という特別な性質を持っている。<br>
このような↑メソッドをコンストラクタと呼ぶ。<br>

コンストラクタ…特定のクラスがnewされた直後に自動的に実行されるメソッド。<br>

上記のHero()はコンストラクタとして定義されており、newされると自動的に実行されてHPに100が代入される。<br>
そのため、mainメソッド側でHPに初期値を代入する必要はない<br>

コンストラクタが定義されたHeroを生み出す<br>

public class Buttle {<br>
  public static void main(String[] args) {<br>
    Hero h = new Hero(); // インスタンス生成と同時にコンストラクタによってHPに100が代入される<br>
    System.out.println(h.hp); // 100と表示される<br>
  }<br>
}<br>

newするだけで自動実行される処理<br>

1.newする(Hero h = new Hero())<br>
2.仮想世界にインスタンスが生まれる<br>
2.自動的にコンストラクタが実行される(今回の場合はHPに100を代入)<br>

ここで意識したいのが、コンストラクタは開発者が直接呼び出すものではないという点。<br>
開発者が直接行うことはあくまでもHero h = new Hero(); でインスタンスを生成することであって、<br>
生成処理の完了後にJVMがHero()を実行してくれる。<br>
h.Hero();のように開発者がコンストラクタを直接呼び出すことは出来ない<br>

コンストラクタは直接呼び出せない<br>
コンストラクタはインスタンスの生成時にJVMによって呼び出されるものであり、
開発者がプログラムで直接呼び出す手段は用意されていない<br>

コンストラクタの定義方法<br>

Q.なぜHeroクラスにはattack()など他にもたくさんメソッドがあるのにHero()だけが自動実行されるのか<br>

A.Hero()だけが自動実行されるメソッドの条件を満たしているから<br>

一見すると、コンストラクタであるHero()も他のメソッドと違いはないように見えるが、
newでインスタンスを生成した時に自動実行されるのはHero()だけ。<br>
実はJavaではクラスに記述されているメソッドのうち、以下の条件↓を全て満たすメソッドだけがコンストラクタとみなされ、自動実行される決まりになっている。<br>

コンストラクタと見做される条件<br>
- メソッド名がクラス名と完全に等しい
- メソッド宣言に戻り値が記述されていない(voidも駄目)

Hero()がコンストラクタとして実行されたのは、Heroクラスの中にHero()という完全に同名で定義されており、その戻り値が記述されていないから。<br>

コンストラクタの定義<br>
public class クラス名{<br>
	クラス名(){
		自動的に実行する処理
	}
}<br>

100などの固定値を入力するだけならば、コンストラクタを用いずにフィールド宣言を「int hp = 100;」とすることでも対応出来る(フィールドの初期化)<br>
しかし、次項のような複雑な条件で初期化したい場合はコンストラクタを使わなければ実現出来ない。<br>

コンストラクタに情報を渡す<br>

HPフィールドは「100」という固定の値で初期化すれば良い為、単純なコンストラクタで済んだ。<br>
しかし勇者の名前は生み出すインスタンスによって異なるはずで、
このような場合は以下↓のようにコンストラクタが毎回異なる追加情報を引数で受け取れるように宣言する事が出来る。<br>

コンストラクタで引数を追加情報として受け取る<br>

public class Hero {<br>
	String name;
	int hp;

	public Hero(String name) {　// 引数として文字列を一つ受け取る
		this.hp = 100;
		this.name = name; // 引数の値でnameフィールドを初期化
	}
}<br>

これで↑Heroクラスはnewするときに名前の初期値も指定できるようになった。<br>

このような↑Heroクラスを利用する場合は、コンストラクタに渡すべき引数をnewするときに指定する。<br>
以下のコード↓ではnewをした時点で与えられた「ミナト」という引数が、コンストラクタHero()が自動実行される際にパラメータとして渡される<br>

newで引数を渡す<br>

public class Battle {<br>
	public static void main(String[] args) {
		Hero h = new Hero("ミナト");　// インスタンス生成後、JVMがコンストラクタを呼び出す際に「ミナト」を渡してもらえる

		System.out.println(h.hp); // 100と表示される
		System.out.println(h.name); // ミナトと表示される
	}
}<br>

newで指定した引数が、コンストラクタ実行時に利用される時↑の様子<br>
1.newする(Hero h = new Hero("ミナト");)<br>
2.仮想世界にインスタンスが生まれる<br>
3.JVMによって自動的にコンストラクタが実行される。このとき引数として「ミナト」が利用される。<br>
Hero(String name)<br>
HPに100を代入、名前に第一引数(ミナト)を代入<br>

1で指定したものが3で利用されるという点がポイント<br>

二つ以上の同名コンストラクタを定義する<br>

現在のHeroクラスには「文字列の引数を一つ受け取るコンストラクタ」が定義されている。<br>
そしてコンストラクタが「newされた際に必ず自動的に実行されるもの」である以上、
「newをする側としては、必ず引数となる文字列を一つ与える」必要がある。<br>

つまり、このコンストラクタを作ったことによって、インスタンスを生成するように
引数なしでnew Hero();を実行するとエラーになる。<br>

一文字以上の名前をつけろって言われてるのに名前が空白(名前をつけない)とエラーになる↑<br>

この問題は「引数を受け取らないコンストラクタ」も同時に定義することで解決出来る。<br>

コンストラクタのオーバーロード<br>

public class Hero {<br>
	String name;
	int hp;

	public Hero(String name) {
		this.hp = 100;
		this.name = name;
	}
	// 以前からあったコンストラクタ1↑

	public Hero() {
		this.hp = 100;
		this.name = "ダミー"; // ダミーの名前を設定する
	}

	// 新しく作ったコンストラクタ2↑
}<br>

「同じ名前だが引数が異なるメソッドを複数定義する」…オーバーロード<br>

オーバーロードはコンストラクタでも可能。<br>
実行時にどのコンストラクタが動くかは、JVMが引数を見て判断してくれる。<br>

複数のコンストラクタが定義されていた場合<br>
newするときに渡した引数の型・数・順番に一致するコンストラクタが動作する。<br>
(動作するコンストラクタは一つのみ)<br>

コンストラクタをオーバーロードしたクラスを利用する例を見てみる<br>

public class Main {<br>
	public static void main(String[] args) {
		Hero h1 = new Hero("ミナト");
		System.out.println(h1.name);
		// 文字列引数があるのでコンストラクタ1が呼び出される↑
		Hero h2 = new Hero();
		System.out.println(h2.name);
		// 引数がないのでコンストラクタ2が呼び出される
	}
}<br>

実行結果<br>
ミナト<br>
ダミー<br>