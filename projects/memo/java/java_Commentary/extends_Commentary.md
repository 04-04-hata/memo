〜継承について〜

継承…すでに作成してあるクラスのメソッドやフィールド(変数)を引き継いだクラスを新しく作成する事。<br>
継承する元のクラスをスーパークラス(親クラス)と呼び、継承する先のクラスをサブクラス(子クラスと呼ぶ。<br>

継承の基本構文↓<br>
修飾子 class クラス名 extends スーパークラス名 {<br>
  //サブクラスの処理<br>
}<br>

クラスを継承する場合は、クラス名の後ろにextends スーパークラス名を記述する。クラスの継承で指定出来るクラスは1つのみ。<br>

〜final修飾子が指定されたクラス〜

final修飾子が指定されたクラスは継承が禁止になる。↓<br>

final public class Human {<br>
}<br>

final public class Employee extends Human{<br>
}<br>
Humanが継承禁止の為、コンパイルエラーになる↑<br>

継承のメリット<br>
スーパークラスのメソッドやフィールド(変数)はそのまま利用して追加したい処理だけを追加できる為、ソースコードの量を減らす事ができる。<br>

メソッドの引数をスーパークラスの型で作成しておけば、サブクラスの型ごとに作成しなくても同じ処理を実行出来る。<br>

〜アップキャスト、ダウンキャスト〜

アップキャスト…サブクラスのインスタンスをスーパークラスの変数に代入する事。<br>
ダウンキャスト…スーパークラスのインスタンスをサブクラスの変数に代入する事。<br>

SubClass subclass = new SubClass();<br>

アップキャスト↓<br>
SuperClass upCastClass = subclass;<br>

ダウンキャスト↓<br>
SuperClass downCastClass = (SubClass) upCastClass;<br>

継承の関係:同じ特徴(情報や振る舞い)を持っている場合に継承してクラスを作成する。<br>

super<br>
superは親インスタンスを指す変数。子インスタンスからスーパクラスのインスタンスのメソッドやフィールド(変数)を利用したい場合に使用する。<br>

// 親インスタンスのフィールド参照<br>
super.フィールド;<br>
// 親インスタンスのメソッド呼び出し<br>
super.メソッド();<br>

superはサブクラスからスーパークラスのコンストラクタを呼び出す場合にも使用する。javaでは、サブクラスのコンストラクタは最初にスーパークラスのコンストラクタを呼び出す必要があり、引数のないデフォルトコンストラクタを呼び出す場合は自動で呼び出される為、明示的に記述する必要はないが、引数があるコンストラクタを呼び出すにはsuperを使って明示的に記述する必要がある。<br>

例↓<br>

public class Student extends Human {<br>
	private int score;
	
	public Student(String name, int age, int score) {
		//Human(スーパークラス)の変数を引き継いでる
		super(name, age);
		this.score = score;
	}
	
	public String getStudentProfile() {
		//age(Human(親クラス)で使ってた変数だからsuper.ってつけなあかん
		String profile = "年齢は" + super.age + "です。";
		profile += "学生で、テストの点数は" + this.score + "点です。";
		return profile;
	}
}
<br>

〜子インスタンスでのthis変数〜

子インスタンスでthis変数を使用してメンバ(クラスに宣言された変数とメソッド)にアクセスすると、子インスタンスに同じ名前のメンバがある場合は子インスタンスのメンバにアクセスし、同じ名前がない場合は親インスタンスのメンバにアクセスする。<br>

〜抽象クラスと抽象メソッド〜

抽象メソッド…処理を記述せずにメソッド名や引数、戻り値だけを定義したメソッド<br>
抽象クラス…抽象メソッドを1つ以上持つクラスの事。<br>

抽象クラスの基本構文<br>

抽象クラスの宣言↓<br>
アクセス修飾子 abstract class クラス名 {<br>
  //抽象メソッドの宣言↓<br>
  アクセス修飾子 abstract 戻り値の型 メソッド名(引数);<br>
}<br>

abstract修飾子を指定してクラスを宣言する事で抽象クラスになる。<br>
また、メソッドにabstract修飾子を指定すると抽象メソッドになる。<br>
抽象メソッドではメソッドブロックの記述をせずに宣言のみ行う。(メソッドブロックを記述するとコンパイルエラーになる)<br>

〜抽象クラスの継承〜

抽象クラスを継承したサブクラスは、抽象メソッドを上書き(オーバーライド)して処理を記述(実装)する必要がある。
実装されてない場合はコンパイルエラーになる。 <br>

抽象クラスのインスタンス生成:抽象クラスはインスタンスを生成することが出来ないので、抽象クラスのメソッドやフィールド(変数)にアクセスする場合は、必ずサブクラスのインスタンスを生成してからアクセスすることになる。<br>


〜インターフェース〜

インターフェース…定数と抽象メソッドだけを持つクラスのようなもの。インターフェースはクラスで実装して利用する。実装したクラスはインターフェース内の抽象メソッドを実装する必要がある<br>

インターフェースの基本構文↓<br>

[public] interface インターフェース名 extends インターフェース名,…{<br>
	//フィールドの宣言(定数)
	(public static final) 定数の型 定数名 = 初期値;
	//メソッドの宣言(抽象メソッド)
	(public abstract) 戻り値の型 メソッド名(引数);
}<br>

インターフェースはclassの代わりにinterfaceで宣言する。<br>
インターフェースに指定出来るアクセス修飾子はpublicかpackage-private(何も書かん)だけ。<br>
インターフェースはインターフェースを継承することが出来、継承する場合はクラスの継承と同じようにインターフェース名の後ろにextends インターフェース名を記述する。クラスの継承は指定出来るクラスは一つのみだが、インターフェースの継承は,(カンマ)区切りで複数のインターフェースを指定出来る。<br>
自動でpublic static finalやpublic abstractが追加される為記述する必要はない。<br>

インターフェースの実装(クラスによるインターフェース実装の基本構文)↓<br>

修飾子 class クラスめい implements インターフェース名, インターフェース名 {<br>
	//インターフェースを実装したメソッドなど
}<br>

インターフェースを実装する場合は、クラス名の後ろにimplements インターフェース名を記述する<br>
インターフェースの実装はインターフェースの継承と同じように複数指定できる。<br>
実装したインターフェースの抽象メソッドを実装する必要があり、実装されていない場合はコンパイルエラーになる。<br>

〜インターフェースのインスタンス生成〜

抽象クラスと同じようにインターフェースもインスタンスを生成することはできないが、インターフェースを実装したクラスも、クラスを継承した場合と同じようにインターフェースの変数に代入して使用できる。継承クラスと同様にメソッドの引数をインターフェースの型で作成しておけば、実装クラスの型ごとに作成しなくても同じ処理を実行出来る。<br>

SampleClass sampleClass = new SampleClass();<br>
//アップキャスト↓
SampleInterface upCastInterface = sampleClass;
//ダウンキャスト↓
SampleClass downCastClass = (SampleClass) upCastInterface;<br>

〜インターフェースの役割〜
インターフェースに宣言できるのは抽象メソッドだけ。理由は、インターフェースが機能を提供するものではなく、共通の機能や企画を規格を企画を企画を定義するための物だから。<br>
インターフェースは抽象メソッドを纏めるためのものって考えでいいかな?<br>

〜defaultメソッドについて〜

defaultメソッド…インターフェース内にデフォルトの処理を実装したメソッドを定義するための機能
<br>

defaultメソッドの基本構文↓<br>

[public] interface インターフェース名 extends インターフェース名, インターフェース名 {<br>
    // デフォルトメソッドの宣言
    default 戻り値の型 メソッド名() {
        // デフォルト処理
    }
}<br>

メソッド宣言にdefaultを指定するとdefaultメソッドになる。<br>
複数のインターフェースを実装していて、その中に同じメソッド名のdefaultメソッドが宣言されている場合は、
海藻が一番近いインターフェースのdefaultメソッドになる。<br>
同じ階層の場合は、そのクラスで処理を記述するか明示的にどちらのdefaultメソッドを使用するかを記述する必要がある。<br>

インターフェースを実装したクラスからdefaultメソッドを呼び出す基本構文↓<br>

インターフェース.super.デフォルトメソッド名();<br>